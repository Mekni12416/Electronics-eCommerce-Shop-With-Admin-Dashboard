pipeline {
    agent any

    environment {
        // Configuration générale
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_USERNAME = 'jihedmekni' 
        // DOCKER_PASSWORD doit être configuré dans Jenkins Credentials
        
        // SonarQube Configuration
        SONAR_HOST_URL = 'http://51.68.70.207:9000' // URL du serveur SonarQube sur la VM
        SONAR_PROJECT_KEY = 'devops-fullstack'
        // SONAR_TOKEN doit être configuré dans Jenkins Credentials (id: sonar-token)

        // API URL pour le build Frontend (IP publique de la VM)
        API_URL = 'http://51.68.70.207:5000'
        
        // Kubeconfig pour Minikube (si nécessaire, souvent géré par l'agent/plugin)
        KUBECONFIG = '/var/lib/jenkins/.kube/config'
    }

    triggers {
        // Vérifie les changements SCM toutes les 5 minutes
        pollSCM('H/5 * * * *')
        // Accepte les notifications de GitHub Webhook
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "Checking out code from Git..."
                    checkout scm
                    sh 'git branch --show-current'
                }
            }
        }

        stage('Install Dependencies') {
            steps {
                script {
                    echo "Installing dependencies..."
                    parallel(
                        "Backend": {
                            dir('server') {
                                sh 'npm ci'
                            }
                        },
                        "Frontend": {
                            // Frontend est à la racine, mais pour l'isolation, on s'assure d'être au bon endroit
                            // Note: L'utilisateur a mentionné 'cd app', mais docker-compose indique '.'
                            // On assume la racine '.'
                            sh 'npm ci'
                        }
                    )
                }
            }
        }

        // stage('Run Tests') {
        //     steps {
        //         script {
        //             echo "Running Unit Tests..."
        //             parallel(
        //                 "Backend Tests": {
        //                     dir('server') {
        //                         // Ignore failure pour ne pas bloquer le pipeline si les tests échouent (pour demo)
        //                         // En prod, enlever returnStatus: true
        //                         sh 'npm test -- --passWithNoTests || true'
        //                     }
        //                 },
        //                 "Frontend Tests": {
        //                     // Frontend root
        //                     sh 'npm test -- --passWithNoTests || true'
        //                 }
        //             )
        //         }
        //     }
        //     post {
        //         always {
        //             // Publie les résultats JUnit s'ils existent (configurer jest-junit)
        //             junit allowEmptyResults: true, testResults: '**/junit.xml'
        //         }
        //     }
        // }

        // stage('SAST - SonarQube Scan') {
        //     steps {
        //         script {
        //             echo "Starting SonarQube Analysis..."
        //             // Nécessite le plugin SonarQube Scanner dans Jenkins
        //             withSonarQubeEnv('SonarQube') { // Nom du serveur configuré dans Jenkins
        //                 // Scan du projet entier (Frontend + Backend)
        //                 // sonar-project.properties devrait être à la racine
        //                 sh """
        //                     sonar-scanner \
        //                     -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
        //                     -Dsonar.sources=. \
        //                     -Dsonar.exclusions=**/node_modules/**,**/.next/**,**/dist/** \
        //                     -Dsonar.host.url=${SONAR_HOST_URL} \
        //                     -Dsonar.login=\${SONAR_TOKEN}
        //                 """
        //             }
        //         }
        //     }
        //     post {
        //         success {
        //             echo "SonarQube analysis successful. Waiting for Quality Gate..."
        //             // waitForQualityGate abortPipeline: true
        //         }
        //     }
        // }

        stage('Build Docker Images') {
            steps {
                script {
                    echo "Building Docker Images..."
                    parallel(
                        "Backend Build": {
                            dir('server') {
                                sh "docker build -t ${DOCKER_USERNAME}/devops-backend:${BUILD_NUMBER} ."
                                sh "docker tag ${DOCKER_USERNAME}/devops-backend:${BUILD_NUMBER} ${DOCKER_USERNAME}/devops-backend:latest"
                            }
                        },
                        "Frontend Build": {
                            // Root context
                            sh """
                                docker build \
                                --build-arg API_URL=${API_URL} \
                                -t ${DOCKER_USERNAME}/devops-frontend:${BUILD_NUMBER} .
                            """
                            sh "docker tag ${DOCKER_USERNAME}/devops-frontend:${BUILD_NUMBER} ${DOCKER_USERNAME}/devops-frontend:latest"
                        }
                    )
                }
            }
        }

        stage('Push to Docker Hub') {
            steps {
                script {
                    echo "Pushing images to Docker Hub..."
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME_VAR')]) {
                        sh "echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME_VAR --password-stdin"
                        
                        // Push Backend
                        sh "docker push ${DOCKER_USERNAME}/devops-backend:${BUILD_NUMBER}"
                        sh "docker push ${DOCKER_USERNAME}/devops-backend:latest"
                        
                        // Push Frontend
                        sh "docker push ${DOCKER_USERNAME}/devops-frontend:${BUILD_NUMBER}"
                        sh "docker push ${DOCKER_USERNAME}/devops-frontend:latest"
                    }
                }
            }
        }

        // stage('Deploy to Staging (Docker Compose)') {
        //     steps {
        //         script {
        //             echo "Deploying to Staging Environment..."
        //             // Simule le déploiement sur staging (machine locale/agent current)
        //             sh 'docker-compose down'
        //             sh 'docker-compose pull'
        //             sh 'docker-compose up -d'
                    
        //             // Attente de la disponibilité
        //             echo "Waiting for services to be ready..."
        //             sleep 30
        //         }
        //     }
        // }

        // stage('DAST - OWASP ZAP Scan') {
        //     steps {
        //         script {
        //             echo "Running DAST Security Scan with OWASP ZAP..."
        //             // Lance le scan ZAP via Docker
        //             // Scanne le frontend sur le port 3000
        //             sh """
        //                 docker run --network host -v \$(pwd):/zap/wrk/:rw -t owasp/zap2docker-stable zap-baseline.py \
        //                 -t http://localhost:3000 \
        //                 -g gen.conf \
        //                 -r zap_report.html || true
        //             """
        //         }
        //     }
        //     post {
        //         always {
        //             // Archive le rapport HTML
        //             archiveArtifacts artifacts: 'zap_report.html', allowEmptyArchive: true
        //         }
        //     }
        // }

        stage('Deploy to Kubernetes (Minikube)') {
            when {
                branch 'main' // Déploiement K8s uniquement sur la branche main
            }
            steps {
                script {
                    // Crée le Secret Kubernetes à partir du fichier .env
                    // On utilise --dry-run=client -o yaml | kubectl apply pour être idempotent
                    sh 'kubectl create secret generic app-env --from-env-file=.env --dry-run=client -o yaml | kubectl apply -f -'

                    // Applique les autres manifests K8s
                    sh 'kubectl apply -f k8s/mysql/'
                    sh 'kubectl apply -f k8s/backend/'
                    sh 'kubectl apply -f k8s/frontend/'
                    
                    // Vérifie le déploiement
                    sh 'kubectl rollout status deployment/mysql-deployment || true'
                    sh 'kubectl rollout status deployment/backend-deployment || true'
                    sh 'kubectl rollout status deployment/frontend-deployment || true'
                    
                    // Affiche les services
                    sh 'kubectl get svc'
                }
            }
        }
    }

    post {
        always {
            echo "Cleaning up workspace..."
            cleanWs()
        }
        success {
            echo "Pipeline succeeded! ✅"
            // slackSend color: "good", message: "Pipeline Suceeded: ${env.JOB_NAME} ${env.BUILD_NUMBER}"
        }
        failure {
            echo "Pipeline failed! ❌"
            // slackSend color: "danger", message: "Pipeline Failed: ${env.JOB_NAME} ${env.BUILD_NUMBER}"
        }
    }
}
